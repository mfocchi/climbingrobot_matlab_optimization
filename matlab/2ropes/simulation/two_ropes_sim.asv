clear all
clc
close all

global delta_duration friction_coefficient Fun  Fut Fr l_0      time    DEBUG p_a1 p_a2

p_a1 = [0;-5;0];
p_a2 = [0;5;0];

g = 9.81;



DEBUG = true;
    
m = 7;   % Mass [kg]



% Fun = solution.Fun;
% Fut = solution.Fut; 
% Fr = solution.Fr;
% time = solution.time;
% p0 = p0(:);

dt = 0.001;

time =[0:dt:5];

%Initial Conditions
% if DEBUG
%   x0 = [theta0; solution.thetad(1); phi0; solution.phid(1); l_0; solution.ld(1)]; %[theta ;d/dt(theta) ;phi ;d/dt(phi) ;l ;d/dt(l)] 
% else
%   x0 = [theta0; 0.;phi0; 0.; l_0; 0.]; %[theta ;d/dt(theta) ;phi ;d/dt(phi) ;l ;d/dt(l)] 
% end

p0 = [2; 3; -10]
l10 = norm(p0 - p_a1)
l20 = norm(p0 - p_a1)
l1d0 = 10;
l2d0 = 5;
J0 = [ (p0-p_a1) ,(p0-p_a2)];



%initial conditions
x0 = [p0; l10; l20; J0*[l1d0; l2d0]; l1d0; l2d0]

%%Simulation:
% define the stop function event
Opt    = odeset('Events', @stopFun);

%1 - Solve differential equations with variable step solver
[time_sim, x] = ode45(@(time_sim,x) diffEq(time_sim,x,m,@FrFun,@FunFun, @FutFun), time, x0, Opt); 

X = x(:,1);
Y = x(:,2);
Z = x(:,3);


% fprintf('original target is  : [%3.2f, %3.2f, %3.2f] \n',pf );
% fprintf('the Matlab touchdown is at : [%3.2f, %3.2f, %3.2f] , for tf = %5.2f\n',X(end), Y(end), Z(end), time_sim(end));
% if MICHELE_APPROACH
%     fprintf('expected optim target    : [%3.2f, %3.2f, %3.2f] \n',solution.achieved_target );
%     fprintf('with error : %3.2f\n',norm([solution.achieved_target(1);solution.achieved_target(2);solution.achieved_target(3)] - [X(end); Y(end);Z(end)]));
% end
% fprintf('with error : %3.2f\n',norm(pf - [X(end); Y(end);Z(end)]));
% %fprintf('with polar error : %3.2f\n',norm([theta_sim(end);phi_sim(end);l_sim(end)] - [solution.theta(end); solution.phi(end); solution.l(end)]));
% [Tf_gazebo, end_gazebo_index] = max(time_gazebo); % there are nans in the log
% fprintf('the Gazebo touchdown is at : [%3.2f, %3.2f, %3.2f] , for tf = %5.2f\n', traj_gazebo(1,end_gazebo_index),  traj_gazebo(2,end_gazebo_index), traj_gazebo(3,end_gazebo_index),Tf_gazebo);
% fprintf('with error : %3.2f\n',norm(pf - [traj_gazebo(1,end_gazebo_index);  traj_gazebo(2,end_gazebo_index); traj_gazebo(3,end_gazebo_index)]));
% 
% 
% % eval total energy sim
% Ekin_sim=   (m*l_sim.^2/2).*(thetad_sim.^2 + sin(theta_sim).^2 .*phid_sim.^2) +m.*ld_sim.^2/2;
% 
% 
% %compare with optim
% % figure(2)
% % plot(time_sim, Ekin_sim,'b.');hold on;grid on;
% % plot(time, solution.energy.Ekin,'r');
% % ylabel('Ekin') 
% % legend('sim', 'opt')

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 3D plot Animation
figure(1)

title('Matlab Animation - simplified model');
xlabel('X ') ; ylabel('Y ') ; zlabel('Z ');

%anchor 1    
plot3(p_a1(1),p_a1(2),p_a1(3),'Marker','*','Color','k','MarkerSize',30);
%anchor2    
plot3(p_a2(1),p_a2(2),p_a2(3),'Marker','*','Color','k','MarkerSize',30);

min_x= 0;
max_x=2;
min_z = -10;
max_z = 1;
min_y = -7;
max_y = 7;

%     drawing a wall at X = 0 
p1 = [0 min_y min_z];
p2 = [0 max_y min_z];
p3 = [0 max_y max_z];
p4 = [0 min_y max_z]; 
Xw = [p1(1) p2(1) p3(1) p4(1)];
Yw = [p1(2) p2(2) p3(2) p4(2)];
Zw = [p1(3) p2(3) p3(3) p4(3)];  
h(3) = fill3(Xw, Yw, Zw, 'b', 'FaceAlpha',.2  );

set(gca,'XLim',[min_x max_x])
set(gca,'YLim',[min_y max_y])
set(gca,'ZLim',[min_z max_z]) 
set(gca,'fontsize',30)

grid on;
xlabel("X" );
label = ylabel("Y" );
%setting for ISO view
%label.Position=label.Position + [-1,0.1,0];
zlabel("Z" );
%title("Reachability region");
%saxis equal;
view(83,50);



%     Vertical line
h(1) = plot3([0 p0(1)],[0 p0(2)],[0 p0(3)],'k-');
%     Point fix
h(2) = plot3(0,0,0,'Marker','*','Color','k','MarkerSize',10);

%     drawing a wall at X = 0 
p1 = [0 min_y min_z];
p2 = [0 max_y min_z];
p3 = [0 max_y max_z];
p4 = [0 min_y max_z]; 
Xw = [p1(1) p2(1) p3(1) p4(1)];
Yw = [p1(2) p2(2) p3(2) p4(2)];
Zw = [p1(3) p2(3) p3(3) p4(3)];  
h(3) = fill3(Xw, Yw, Zw, 'b', 'FaceAlpha',.5  );

h(4) = animatedline('color','r', 'linewidth',3);
h(5) = animatedline('color','b', 'linewidth',3);
%Pendulum rod (red)
h(6) = animatedline('color','r', 'linewidth',3);
%Pendulum sphere (red)
h(7) = animatedline('Marker','o','Color','k','MarkerFaceColor','r','MarkerSize',10);

h(8) = plot3(pf(1),pf(2),pf(3),'Marker','.','Color','r','MarkerSize',50);
if OBSTACLE 
    cone(0,1.5,0);
end


 view(33,63);
% Loop for animation
for i = 1:length(X)
    
    %Pendulum trajectory
    if time_sim(i)<=delta_duration
        addpoints(h(4), X(i),Y(i),Z(i)); 

    else 
        addpoints(h(5)  ,X(i),Y(i),Z(i))
       
    end
      
    drawnow limitrate;
    pause(0.001);
 
end






function [fr] = FrFun(t)
global   Fr time
   idx = min(find(time>=t));
   fr = Fr(idx);
end


function [fun] = FunFun(t)
global   Fun time delta_duration MICHELE_APPROACH
    if MICHELE_APPROACH
        if (t <= delta_duration)
            fun = Fun;
        else
            fun = 0;
        end
    else
       idx = min(find(time>=t));
       fun = Fun(idx);   
    end
end


function [fut] = FutFun(t)
global   Fut time delta_duration MICHELE_APPROACH
    if MICHELE_APPROACH
        if (t <= delta_duration)
            fut = Fut;
        else
            fut = 0;
        end
    else
       idx = min(find(time>=t));
       fut = Fut(idx);   
    end
end

function [value, isterminal, direction] = stopFun(t, x)
        global time 
        theta = x(1);
        dtheta = x(2);
        phi = x(3);
        dphi = x(4);
        l = x(5);
        dl = x(6);
           
        X = l*cos(phi)*sin(theta);    
        Y = l*sin(phi)*sin(theta);
        Z = -l*cos(theta);
        
        %value =  (Z - target_height);
        value =  (time(end) - t);    
        %direction  =-1 Detect zero crossings of value in the negative direction only
        %direction  =0 Detect all zero crossings of value 
        %direction  =1 Detect zero crossings of value  in the positive direction only
        
        direction  = -1;
        isterminal = 1;   % Stop the integration

       
end

function [dxdt] = diffEq(t,x, m, Fr, Fun ,Fut)

global DEBUG p_a1 p_a2

%x = [theta, dottheta, phi, dotphi, l, dotl]
g = 9.81;   %Gravity   [m/s2]

%Retrieving states
px = x(1);
py = x(2);
pz = x(3);
l1 = x(4);
l2 = x(5);
dpx = x(6);
dpy = x(7);
dpz = x(8);
dl1 = x(9);
dl2 = x(10);

p = [px;py;pz];

  A = [m*eye(3) ,        0  ,      0,
         2*(p-p_a1)'  , -1    ,   0,
         2*(p-p_a2)',   0    ,   -1];
    
    b = [m*g; -2*dp'*dp ; -2*dp'*dp ];
    y = inv(A)*b;

% if DEBUG % reset the state already
%     A = [m*eye(3)      0        0,
%          2*(p-p_a1)'   -1       0,
%          2*(p-p_a2)'   0       -1];
%     
%     b = [m*g; -2*dp'*dp ; -2*dp'*dp ];
%     y = inv(A)*b;
%      
% else
% %     ddtheta = -(2*dtheta*dl)/l + cos(theta)*sin(theta)*(dphi^2)-(g/l)*sin(theta)+Fun(t)/(m*l);
% %     ddphi = -2*(cos(theta)/sin(theta))*dphi*dtheta  -(2/l)*dphi*dl+ Fut(t)/(m*l*sin(theta));
% %     ddl = l*(dtheta^2)+l*(sin(theta)^2)*dphi^2+g*cos(theta)+(1/m)*Fr(t);
% end

dxdt = [y; dpx; dpy; dpz; dl1; dl2];


end

